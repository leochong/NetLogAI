-- NetLog Parser Script for Custom Syslog Format
-- Version: 1.0.0
-- Author: NetLogAI Community
-- Description: Parser for custom application syslog messages

-- Parser metadata
local parser_name = "Custom Application Syslog Parser"
local parser_version = "1.0.0"
local device_type = "GenericSyslog"

-- Supported patterns (this parser looks for specific application prefixes)
local supported_patterns = {
    ".*\\[MYAPP\\].*",     -- Messages with [MYAPP] prefix
    ".*MYAPP:.*",          -- Messages with MYAPP: prefix
    ".*myapp\\[\\d+\\]:.*" -- Messages with myapp[pid]: format
}

-- Severity keyword mapping
local severity_keywords = {
    ["FATAL"] = 0,    -- Emergency
    ["CRITICAL"] = 2, -- Critical
    ["ERROR"] = 3,    -- Error
    ["WARN"] = 4,     -- Warning
    ["WARNING"] = 4,  -- Warning
    ["INFO"] = 6,     -- Informational
    ["DEBUG"] = 7,    -- Debug
    ["TRACE"] = 7     -- Debug
}

-- Function to check if this parser can handle a message
function can_parse(raw_message)
    if not raw_message then return false end
    
    -- Check for our application indicators
    if string.find(raw_message, "%[MYAPP%]") then return true end
    if string.find(raw_message, "MYAPP:") then return true end
    if string.find(raw_message, "myapp%[%d+%]:") then return true end
    
    return false
end

-- Extract severity from message content
function extract_severity(message)
    local upper_msg = string.upper(message)
    
    for keyword, level in pairs(severity_keywords) do
        if string.find(upper_msg, keyword) then
            return level
        end
    end
    
    return 6  -- Default to INFO
end

-- Extract process ID from message
function extract_process_id(message)
    -- Look for patterns like myapp[1234]: or [PID:1234]
    local pid = string.match(message, "myapp%[(%d+)%]:")
    if pid then return tonumber(pid) end
    
    pid = string.match(message, "%[PID:(%d+)%]")
    if pid then return tonumber(pid) end
    
    return nil
end

-- Extract timestamp from syslog format
function extract_timestamp(message)
    -- Look for standard syslog timestamp: Nov 15 10:30:25
    local month, day, time = string.match(message, "(%a+)%s+(%d+)%s+(%d+:%d+:%d+)")
    if month and day and time then
        -- For now, return current timestamp
        -- In a real implementation, you would convert this to proper timestamp
        return netlog.parse_timestamp(month .. " " .. day .. " " .. time)
    end
    
    -- Look for ISO timestamp: 2024-11-15T10:30:25
    local iso_timestamp = string.match(message, "(%d%d%d%d%-%d%d%-%d%dT%d%d:%d%d:%d%d)")
    if iso_timestamp then
        return netlog.parse_timestamp(iso_timestamp)
    end
    
    return nil
end

-- Extract hostname from syslog message
function extract_hostname(message)
    -- Standard syslog format: timestamp hostname process[pid]: message
    local hostname = string.match(message, "%a+%s+%d+%s+%d+:%d+:%d+%s+([%w%.%-]+)%s+")
    return hostname or ""
end

-- Clean and extract the actual log message
function extract_clean_message(raw_message)
    -- Remove syslog prefix and extract just the application message
    local message = raw_message
    
    -- Remove timestamp prefix
    message = string.gsub(message, "^%a+%s+%d+%s+%d+:%d+:%d+%s+", "")
    
    -- Remove hostname prefix
    message = string.gsub(message, "^[%w%.%-]+%s+", "")
    
    -- Remove process name and PID prefix
    message = string.gsub(message, "^myapp%[%d+%]:%s*", "")
    
    -- Remove application prefix
    message = string.gsub(message, "^%[MYAPP%]%s*", "")
    message = string.gsub(message, "^MYAPP:%s*", "")
    
    return message
end

-- Main parsing function
function parse(raw_message)
    if not can_parse(raw_message) then
        return nil
    end
    
    netlog.log_debug("Parsing custom syslog message")
    
    -- Create log entry
    local entry = netlog.create_log_entry()
    
    -- Extract timestamp
    local timestamp = extract_timestamp(raw_message)
    if timestamp then
        entry.timestamp = timestamp
    end
    
    -- Extract hostname
    local hostname = extract_hostname(raw_message)
    if hostname and hostname ~= "" then
        entry.hostname = hostname
    end
    
    -- Extract process information
    local process_id = extract_process_id(raw_message)
    if process_id then
        entry.process_id = process_id
    end
    entry.process_name = "myapp"
    
    -- Extract and clean message
    local clean_message = extract_clean_message(raw_message)
    entry.message = clean_message
    
    -- Determine severity
    entry.severity = extract_severity(raw_message)
    
    -- Set facility
    entry.facility = "LOCAL0"  -- Typical for custom applications
    
    -- Determine message category for metadata
    local category = "general"
    if string.find(string.upper(clean_message), "LOGIN") then
        category = "authentication"
    elseif string.find(string.upper(clean_message), "CONNECT") or 
           string.find(string.upper(clean_message), "DISCONNECT") then
        category = "network"
    elseif string.find(string.upper(clean_message), "ERROR") or 
           string.find(string.upper(clean_message), "FAIL") then
        category = "error"
    elseif string.find(string.upper(clean_message), "START") or 
           string.find(string.upper(clean_message), "STOP") then
        category = "service"
    end
    
    -- Set metadata
    entry.metadata = {
        category = category,
        parser = "custom_syslog",
        raw_length = tostring(#raw_message)
    }
    
    -- Add extracted fields to metadata
    if process_id then
        entry.metadata.extracted_pid = tostring(process_id)
    end
    
    netlog.log_debug("Successfully parsed custom syslog message")
    return entry
end

-- Required function: return device type
function get_device_type()
    return device_type
end

-- Required function: return parser name
function get_parser_name()
    return parser_name
end

-- Required function: return parser version
function get_version()
    return parser_version
end

-- Required function: return supported patterns
function get_supported_patterns()
    return supported_patterns
end