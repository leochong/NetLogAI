--[[
NetLog Parser DSL Script: Cisco IOS General Parser
Device Type: CiscoIOS
Version: 1.2.0
Description: General-purpose parser for Cisco IOS/IOS-XE log messages

Supported log formats:
- %FACILITY-SEVERITY-MNEMONIC: message
- Sequence numbers and timestamps
- Interface events, routing protocols, system events

Example messages:
- %LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0/1, changed state to down
- %BGP-3-NOTIFICATION: sent to neighbor 192.168.1.2 4/0 (hold time expired)
- %SYS-5-CONFIG_I: Configured from console by admin on vty0 (192.168.1.100)
]]--

-- Parser metadata
local PARSER_NAME = "Cisco IOS General Parser"
local PARSER_VERSION = "1.2.0"
local DEVICE_TYPE = "CiscoIOS"

-- Common patterns for Cisco IOS logs
local patterns = {
    -- Standard Cisco IOS format with facility, severity, and mnemonic
    standard = "^%%([%w_%-]+)%-(%d+)%-([%w_]+): (.+)$",

    -- With sequence number prefix
    with_sequence = "^(%d+): %%([%w_%-]+)%-(%d+)%-([%w_]+): (.+)$",

    -- With timestamp prefix (various formats)
    with_timestamp = "^([%w: ]+): %%([%w_%-]+)%-(%d+)%-([%w_]+): (.+)$",

    -- With both sequence and timestamp
    full_format = "^(%d+): ([%w: ]+): %%([%w_%-]+)%-(%d+)%-([%w_]+): (.+)$"
}

-- Severity level mapping (Cisco uses 0-7 scale)
local severity_map = {
    [0] = "emergency",
    [1] = "alert",
    [2] = "critical",
    [3] = "error",
    [4] = "warning",
    [5] = "notice",
    [6] = "info",
    [7] = "debug"
}

-- Common Cisco IOS facilities and their typical severity levels
local facility_context = {
    LINEPROTO = {description = "Line Protocol", common_severity = 5},
    BGP = {description = "Border Gateway Protocol", common_severity = 3},
    OSPF = {description = "OSPF Routing Protocol", common_severity = 5},
    SYS = {description = "System", common_severity = 5},
    LINK = {description = "Link Status", common_severity = 3},
    CONFIG = {description = "Configuration", common_severity = 5},
    SNMP = {description = "SNMP", common_severity = 6},
    AAA = {description = "Authentication/Authorization", common_severity = 6}
}

function get_parser_name()
    return PARSER_NAME
end

function get_version()
    return PARSER_VERSION
end

function get_device_type()
    return DEVICE_TYPE
end

function get_supported_patterns()
    local pattern_list = {}
    for name, pattern in pairs(patterns) do
        table.insert(pattern_list, pattern)
    end
    return pattern_list
end

function can_parse(raw_message)
    -- Quick rejection for non-Cisco messages
    if not string.find(raw_message, "%%", 1, true) then
        return false
    end

    -- Check if it matches any of our patterns
    for _, pattern in pairs(patterns) do
        if string.match(raw_message, pattern) then
            return true
        end
    end

    return false
end

function parse(raw_message)
    netlog.log_debug("Parsing Cisco IOS message: " .. raw_message)

    local sequence, timestamp_str, facility, severity_num, mnemonic, message
    local parsed = false

    -- Try different patterns in order of complexity
    sequence, timestamp_str, facility, severity_num, mnemonic, message =
        string.match(raw_message, patterns.full_format)
    if facility then
        parsed = true
    else
        timestamp_str, facility, severity_num, mnemonic, message =
            string.match(raw_message, patterns.with_timestamp)
        if facility then
            parsed = true
        else
            sequence, facility, severity_num, mnemonic, message =
                string.match(raw_message, patterns.with_sequence)
            if facility then
                parsed = true
            else
                facility, severity_num, mnemonic, message =
                    string.match(raw_message, patterns.standard)
                if facility then
                    parsed = true
                end
            end
        end
    end

    if not parsed then
        netlog.log_debug("No pattern matched for message")
        return nil
    end

    -- Create log entry
    local entry = netlog.create_log_entry()

    -- Parse timestamp if present
    if timestamp_str then
        local timestamp = netlog.parse_timestamp(timestamp_str)
        entry.timestamp = timestamp
    else
        -- Use current time if no timestamp in log
        entry.timestamp = os.time()
    end

    -- Convert severity number to string
    local severity_int = tonumber(severity_num) or 6
    entry.severity = severity_map[severity_int] or "info"

    -- Set basic fields
    entry.facility = facility
    entry.message = message
    entry.process_name = facility .. "-" .. mnemonic

    -- Add metadata
    entry.metadata = {
        cisco_facility = facility,
        cisco_mnemonic = mnemonic,
        cisco_severity_code = severity_num,
        message_format = "cisco_ios"
    }

    -- Add sequence number if present
    if sequence then
        entry.metadata.sequence_number = sequence
    end

    -- Add facility context information
    if facility_context[facility] then
        entry.metadata.facility_description = facility_context[facility].description
    end

    -- Parse specific message types for additional metadata
    parse_specific_message_type(entry, facility, mnemonic, message)

    netlog.log_debug("Successfully parsed Cisco IOS message")
    return entry
end

function parse_specific_message_type(entry, facility, mnemonic, message)
    -- Interface-related messages
    if facility == "LINEPROTO" and mnemonic == "UPDOWN" then
        local interface, state = string.match(message, "Line protocol on Interface (%S+), changed state to (%w+)")
        if interface and state then
            entry.metadata.interface = interface
            entry.metadata.interface_state = state
            entry.metadata.event_type = "interface_state_change"
        end

    -- BGP messages
    elseif facility == "BGP" then
        if mnemonic == "NOTIFICATION" then
            local neighbor, error_code, subcode = string.match(message, "sent to neighbor (%S+) (%d+)/(%d+)")
            if neighbor then
                entry.metadata.bgp_neighbor = neighbor
                entry.metadata.bgp_error_code = error_code
                entry.metadata.bgp_error_subcode = subcode
                entry.metadata.event_type = "bgp_notification"
            end
        elseif string.find(mnemonic, "ADJCHANGE") then
            local neighbor = string.match(message, "neighbor (%S+)")
            if neighbor then
                entry.metadata.bgp_neighbor = neighbor
                entry.metadata.event_type = "bgp_adjacency_change"
            end
        end

    -- OSPF messages
    elseif facility == "OSPF" then
        if mnemonic == "ADJCHG" then
            local process, neighbor, interface, old_state, new_state =
                string.match(message, "Process (%d+), Nbr (%S+) on (%S+) from (%w+) to (%w+)")
            if process and neighbor then
                entry.metadata.ospf_process = process
                entry.metadata.ospf_neighbor = neighbor
                entry.metadata.interface = interface
                entry.metadata.old_state = old_state
                entry.metadata.new_state = new_state
                entry.metadata.event_type = "ospf_adjacency_change"
            end
        end

    -- System configuration messages
    elseif facility == "SYS" and mnemonic == "CONFIG_I" then
        local source, user, terminal, ip = string.match(message, "Configured from (%w+) by (%w+) on (%w+) %(([%d%.]+)%)")
        if user then
            entry.metadata.config_source = source
            entry.metadata.config_user = user
            entry.metadata.config_terminal = terminal
            entry.metadata.config_source_ip = ip
            entry.metadata.event_type = "configuration_change"
        end

    -- Authentication messages
    elseif facility == "SEC_LOGIN" then
        if string.find(message, "Login Success") then
            local user, source = string.match(message, "Login Success .* from (%S+) on (%S+)")
            if user then
                entry.metadata.auth_user = user
                entry.metadata.auth_source = source
                entry.metadata.event_type = "authentication_success"
            end
        elseif string.find(message, "Login failed") then
            entry.metadata.event_type = "authentication_failure"
        end
    end

    -- Add more specific parsing as needed
end

-- Helper function for testing (optional)
function run_self_test()
    local test_messages = {
        "%LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0/1, changed state to down",
        "123: Jan 15 10:30:45: %BGP-3-NOTIFICATION: sent to neighbor 192.168.1.2 4/0 (hold time expired)",
        "%SYS-5-CONFIG_I: Configured from console by admin on vty0 (192.168.1.100)",
        "456: %OSPF-5-ADJCHG: Process 1, Nbr 10.0.0.2 on FastEthernet0/0 from FULL to DOWN"
    }

    netlog.log_info("Running self-test for Cisco IOS General Parser")

    for i, msg in ipairs(test_messages) do
        local can_parse_result = can_parse(msg)
        local parse_result = parse(msg)

        netlog.log_info(string.format("Test %d - Can parse: %s, Parse result: %s",
            i, tostring(can_parse_result), parse_result and "success" or "failed"))
    end
end

-- Initialize function (called when parser is loaded)
function initialize()
    netlog.log_info("Cisco IOS General Parser v" .. PARSER_VERSION .. " initialized")
end